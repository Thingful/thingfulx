// Code generated by protoc-gen-go. DO NOT EDIT.
// source: channels.proto

package thingfulx

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Visibility defines an access level for a resource using definitions provided
// by the ODI. Open means accessible without authentication, Shared is publicly
// accessible provided some registration and authentication process is followed,
// and Closed means the resource is private, only accessible with explicit
// permission.
type Visibility int32

const (
	Visibility_OPEN   Visibility = 0
	Visibility_SHARED Visibility = 1
	Visibility_CLOSED Visibility = 3
)

var Visibility_name = map[int32]string{
	0: "OPEN",
	1: "SHARED",
	3: "CLOSED",
}

var Visibility_value = map[string]int32{
	"OPEN":   0,
	"SHARED": 1,
	"CLOSED": 3,
}

func (x Visibility) String() string {
	return proto.EnumName(Visibility_name, int32(x))
}

func (Visibility) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{0}
}

// The DataType enum is used to encode information about the data type of the
// values returned in the repeated Observations list.
type DataType int32

const (
	DataType_NUMBER    DataType = 0
	DataType_INTEGER   DataType = 1
	DataType_STRING    DataType = 2
	DataType_DATE_TIME DataType = 3
	DataType_TIME      DataType = 4
	DataType_BOOLEAN   DataType = 5
	DataType_BYTES     DataType = 6
	DataType_UNKNOWN   DataType = 7
)

var DataType_name = map[int32]string{
	0: "NUMBER",
	1: "INTEGER",
	2: "STRING",
	3: "DATE_TIME",
	4: "TIME",
	5: "BOOLEAN",
	6: "BYTES",
	7: "UNKNOWN",
}

var DataType_value = map[string]int32{
	"NUMBER":    0,
	"INTEGER":   1,
	"STRING":    2,
	"DATE_TIME": 3,
	"TIME":      4,
	"BOOLEAN":   5,
	"BYTES":     6,
	"UNKNOWN":   7,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{1}
}

// Channel represents a single data channel being provided by an IoT device
// somewhere in the world.
type Channel struct {
	// URL contains a unique URL for the Channel that must be the URL at which the
	// Channel's data is available
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Title contains a unique (if possible) title for the Channel
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Description contains a human centered description of the Channel if
	// available.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Webpage contains a human centered web resource where information about the
	// specific device providing the Channel may be found
	Webpage string `protobuf:"bytes,4,opt,name=webpage,proto3" json:"webpage,omitempty"`
	// IndexedAt contains an RFC3339 timestamp showing when the Channel was indexed
	IndexedAt string `protobuf:"bytes,5,opt,name=indexed_at,json=indexedAt,proto3" json:"indexed_at,omitempty"`
	// Location contains the geographical location of the Channel
	Location *Location `protobuf:"bytes,6,opt,name=location,proto3" json:"location,omitempty"`
	// ProviderUID must return the unique identifier of the provider on which the
	// Device publishes this Channel. This is a required field.
	ProviderUid string `protobuf:"bytes,7,opt,name=provider_uid,json=providerUid,proto3" json:"provider_uid,omitempty"`
	// Metadata contains an optional list of metadata about the Channel
	Metadata []*Metadata `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty"`
	// Visibility returns the visibility status of the Channel. Can be one of OPEN
	// - open API freely accessible with no authentication, SHARED - available via
	// a public API provided suitable authentication is supplied, or CLOSED - only
	// available via a private API. This is a required field.
	Visibility Visibility `protobuf:"varint,9,opt,name=visibility,proto3,enum=thingfulx.protobuf.Visibility" json:"visibility,omitempty"`
	// DataLicense returns the unique identifying URL of a specific data license
	// that the data provider has chosen to apply to their data. This is an
	// optional field.
	DataLicense *DataLicense `protobuf:"bytes,10,opt,name=data_license,json=dataLicense,proto3" json:"data_license,omitempty"`
	// Attributions contains a list of attributions we require to add to a
	// channel. Typically there will only be one, but some providers may require
	// multiple attributions.
	Attributions []*Attribution `protobuf:"bytes,11,rep,name=attributions,proto3" json:"attributions,omitempty"`
	// UpdateInterval returns the update frequency of the data resource expressed
	// as an integer number of seconds.
	UpdateInterval int32 `protobuf:"varint,12,opt,name=update_interval,json=updateInterval,proto3" json:"update_interval,omitempty"`
	// QuantityKind is used to describe the specific physical quantity kind this
	// channel measures. This will be expressed as a namespaced string, i.e.
	// m3-lite:AirTemperature where this compressed string can be expanded to URL
	// that uniquely identifies the quantity kind.
	QuantityKind string `protobuf:"bytes,13,opt,name=quantity_kind,json=quantityKind,proto3" json:"quantity_kind,omitempty"`
	// Unit is used to describe the unit in which the Channel publishes its data.
	// This will be expressed as a namespaced string, i.e. m3-lite:DegreeCelsius
	// which can be expanded to a URL that uniqely identifies the unit, and can be
	// used to obtain the symbol or to do conversions.
	Unit string `protobuf:"bytes,14,opt,name=unit,proto3" json:"unit,omitempty"`
	// DomainOfInterest is used to describe the broad category of the channel, and
	// as above will be expressed as a namespaced string, i.e.
	// m3-lite:Environment, which as above can be expanded.
	DomainOfInterest []string `protobuf:"bytes,15,rep,name=domain_of_interest,json=domainOfInterest,proto3" json:"domain_of_interest,omitempty"`
	// MeasuredBy is used to describe the type of sensor that was used to obtain
	// the channel's data. Expressed as a namespaced string, i.e.
	// m3-lite:Seismometer.
	MeasuredBy string `protobuf:"bytes,16,opt,name=measured_by,json=measuredBy,proto3" json:"measured_by,omitempty"`
	// DataType is used to encode the type of the value contained in each
	// observation.
	DataType DataType `protobuf:"varint,17,opt,name=data_type,json=dataType,proto3,enum=thingfulx.protobuf.DataType" json:"data_type,omitempty"`
	// Observations returns a list of data observation values that represent
	// concrete data recordings for the Channel.
	Observations         []*Observation `protobuf:"bytes,18,rep,name=observations,proto3" json:"observations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Channel) Reset()         { *m = Channel{} }
func (m *Channel) String() string { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()    {}
func (*Channel) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{0}
}

func (m *Channel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Channel.Unmarshal(m, b)
}
func (m *Channel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Channel.Marshal(b, m, deterministic)
}
func (m *Channel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Channel.Merge(m, src)
}
func (m *Channel) XXX_Size() int {
	return xxx_messageInfo_Channel.Size(m)
}
func (m *Channel) XXX_DiscardUnknown() {
	xxx_messageInfo_Channel.DiscardUnknown(m)
}

var xxx_messageInfo_Channel proto.InternalMessageInfo

func (m *Channel) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Channel) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Channel) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Channel) GetWebpage() string {
	if m != nil {
		return m.Webpage
	}
	return ""
}

func (m *Channel) GetIndexedAt() string {
	if m != nil {
		return m.IndexedAt
	}
	return ""
}

func (m *Channel) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Channel) GetProviderUid() string {
	if m != nil {
		return m.ProviderUid
	}
	return ""
}

func (m *Channel) GetMetadata() []*Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Channel) GetVisibility() Visibility {
	if m != nil {
		return m.Visibility
	}
	return Visibility_OPEN
}

func (m *Channel) GetDataLicense() *DataLicense {
	if m != nil {
		return m.DataLicense
	}
	return nil
}

func (m *Channel) GetAttributions() []*Attribution {
	if m != nil {
		return m.Attributions
	}
	return nil
}

func (m *Channel) GetUpdateInterval() int32 {
	if m != nil {
		return m.UpdateInterval
	}
	return 0
}

func (m *Channel) GetQuantityKind() string {
	if m != nil {
		return m.QuantityKind
	}
	return ""
}

func (m *Channel) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *Channel) GetDomainOfInterest() []string {
	if m != nil {
		return m.DomainOfInterest
	}
	return nil
}

func (m *Channel) GetMeasuredBy() string {
	if m != nil {
		return m.MeasuredBy
	}
	return ""
}

func (m *Channel) GetDataType() DataType {
	if m != nil {
		return m.DataType
	}
	return DataType_NUMBER
}

func (m *Channel) GetObservations() []*Observation {
	if m != nil {
		return m.Observations
	}
	return nil
}

// Attribution is a message type used to add attributions to a Channel.
type Attribution struct {
	// Name is the name of at attribution
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// URL  is the URL of  the attribution
	URL                  string   `protobuf:"bytes,2,opt,name=URL,proto3" json:"URL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Attribution) Reset()         { *m = Attribution{} }
func (m *Attribution) String() string { return proto.CompactTextString(m) }
func (*Attribution) ProtoMessage()    {}
func (*Attribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{1}
}

func (m *Attribution) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Attribution.Unmarshal(m, b)
}
func (m *Attribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Attribution.Marshal(b, m, deterministic)
}
func (m *Attribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attribution.Merge(m, src)
}
func (m *Attribution) XXX_Size() int {
	return xxx_messageInfo_Attribution.Size(m)
}
func (m *Attribution) XXX_DiscardUnknown() {
	xxx_messageInfo_Attribution.DiscardUnknown(m)
}

var xxx_messageInfo_Attribution proto.InternalMessageInfo

func (m *Attribution) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Attribution) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

// Location is a message type used to describe a physical location
type Location struct {
	// Longitude contains the decimal longitude of a geographical location
	Longitude float32 `protobuf:"fixed32,1,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// Latitude contains the decimal latitude of a geographical location
	Latitude float32 `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// Elevation contains the elevation of a geographical location expressed as
	// metres above sea level if available
	Elevation            float32  `protobuf:"fixed32,3,opt,name=elevation,proto3" json:"elevation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{2}
}

func (m *Location) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Location.Unmarshal(m, b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Location.Marshal(b, m, deterministic)
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return xxx_messageInfo_Location.Size(m)
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Location) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Location) GetElevation() float32 {
	if m != nil {
		return m.Elevation
	}
	return 0
}

// Metadata is a message type used to describe arbitrary metadata properties for
// a Channel
type Metadata struct {
	// Property contains a namespaced property of a channel that we wish to describe.
	Property string `protobuf:"bytes,1,opt,name=property,proto3" json:"property,omitempty"`
	// Value contains the value we wish to assign to that property in order to
	// correctly describe some aspect of the Channel
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{3}
}

func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata.Unmarshal(m, b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return xxx_messageInfo_Metadata.Size(m)
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetProperty() string {
	if m != nil {
		return m.Property
	}
	return ""
}

func (m *Metadata) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Observation is a messages used to record a single data value at a point in
// time for a channel
type Observation struct {
	// RecordedAt records the timestamp at which the observation was recorded in
	// UTC and expressed as an RFC3339 string.
	RecordedAt string `protobuf:"bytes,1,opt,name=recorded_at,json=recordedAt,proto3" json:"recorded_at,omitempty"`
	// Each Observation must include its own location as this allows us to place
	// an observation in a particular place at a particular time which may be
	// different from the current location of the Channel.
	Location *Location `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// Value includes the actual value of the Observation at the instant of time
	// encoded as a string.
	Value                string   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Observation) Reset()         { *m = Observation{} }
func (m *Observation) String() string { return proto.CompactTextString(m) }
func (*Observation) ProtoMessage()    {}
func (*Observation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{4}
}

func (m *Observation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Observation.Unmarshal(m, b)
}
func (m *Observation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Observation.Marshal(b, m, deterministic)
}
func (m *Observation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Observation.Merge(m, src)
}
func (m *Observation) XXX_Size() int {
	return xxx_messageInfo_Observation.Size(m)
}
func (m *Observation) XXX_DiscardUnknown() {
	xxx_messageInfo_Observation.DiscardUnknown(m)
}

var xxx_messageInfo_Observation proto.InternalMessageInfo

func (m *Observation) GetRecordedAt() string {
	if m != nil {
		return m.RecordedAt
	}
	return ""
}

func (m *Observation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Observation) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// DataLicense is a message used to describe the properties of a data license
type DataLicense struct {
	// Name is a human friendly label or name for the data license.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Url is a unique identifier for the license that should also be the URL
	// where the text of the license is available.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// LegalCodeUrl is a link to a long or legal version of the license. This may
	// be the same as the above URL if no more detailed version is available.
	LegalCodeUrl string `protobuf:"bytes,3,opt,name=legal_code_url,json=legalCodeUrl,proto3" json:"legal_code_url,omitempty"`
	// Permits is a list of properties which define what usage the license permits.
	Permits []string `protobuf:"bytes,4,rep,name=permits,proto3" json:"permits,omitempty"`
	// Requires is a list of properties which define what requirements the license
	// has.
	Requires []string `protobuf:"bytes,5,rep,name=requires,proto3" json:"requires,omitempty"`
	// Permits is a list of properties which define what the license prohibits
	Prohibits            []string `protobuf:"bytes,6,rep,name=prohibits,proto3" json:"prohibits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DataLicense) Reset()         { *m = DataLicense{} }
func (m *DataLicense) String() string { return proto.CompactTextString(m) }
func (*DataLicense) ProtoMessage()    {}
func (*DataLicense) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb5b11d5b15e5ec, []int{5}
}

func (m *DataLicense) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DataLicense.Unmarshal(m, b)
}
func (m *DataLicense) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DataLicense.Marshal(b, m, deterministic)
}
func (m *DataLicense) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataLicense.Merge(m, src)
}
func (m *DataLicense) XXX_Size() int {
	return xxx_messageInfo_DataLicense.Size(m)
}
func (m *DataLicense) XXX_DiscardUnknown() {
	xxx_messageInfo_DataLicense.DiscardUnknown(m)
}

var xxx_messageInfo_DataLicense proto.InternalMessageInfo

func (m *DataLicense) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataLicense) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *DataLicense) GetLegalCodeUrl() string {
	if m != nil {
		return m.LegalCodeUrl
	}
	return ""
}

func (m *DataLicense) GetPermits() []string {
	if m != nil {
		return m.Permits
	}
	return nil
}

func (m *DataLicense) GetRequires() []string {
	if m != nil {
		return m.Requires
	}
	return nil
}

func (m *DataLicense) GetProhibits() []string {
	if m != nil {
		return m.Prohibits
	}
	return nil
}

func init() {
	proto.RegisterEnum("thingfulx.protobuf.Visibility", Visibility_name, Visibility_value)
	proto.RegisterEnum("thingfulx.protobuf.DataType", DataType_name, DataType_value)
	proto.RegisterType((*Channel)(nil), "thingfulx.protobuf.Channel")
	proto.RegisterType((*Attribution)(nil), "thingfulx.protobuf.Attribution")
	proto.RegisterType((*Location)(nil), "thingfulx.protobuf.Location")
	proto.RegisterType((*Metadata)(nil), "thingfulx.protobuf.Metadata")
	proto.RegisterType((*Observation)(nil), "thingfulx.protobuf.Observation")
	proto.RegisterType((*DataLicense)(nil), "thingfulx.protobuf.DataLicense")
}

func init() { proto.RegisterFile("channels.proto", fileDescriptor_6eb5b11d5b15e5ec) }

var fileDescriptor_6eb5b11d5b15e5ec = []byte{
	// 776 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x8e, 0xe3, 0x34,
	0x14, 0xde, 0xfe, 0x27, 0x27, 0x9d, 0x6e, 0xb0, 0xb8, 0xb0, 0xd0, 0xc0, 0x96, 0x82, 0x44, 0xb5,
	0x42, 0x73, 0xb1, 0x7b, 0x03, 0x12, 0x42, 0x6a, 0x67, 0xa2, 0xa5, 0xda, 0x4e, 0x8a, 0x3c, 0x2d,
	0x08, 0x6e, 0x22, 0xa7, 0xf6, 0xcc, 0x58, 0xa4, 0x49, 0xd6, 0x71, 0x86, 0xed, 0x0d, 0x6f, 0xc2,
	0x23, 0xf0, 0x8e, 0xc8, 0x76, 0x7e, 0xba, 0x30, 0x73, 0xb1, 0x77, 0xe7, 0x7c, 0xe7, 0xc7, 0x3e,
	0x9f, 0xcf, 0x67, 0x98, 0xec, 0xef, 0x69, 0x9a, 0xf2, 0xa4, 0xb8, 0xc8, 0x65, 0xa6, 0x32, 0x84,
	0xd4, 0xbd, 0x48, 0xef, 0x6e, 0xcb, 0xe4, 0xbd, 0x05, 0xe2, 0xf2, 0x76, 0xf6, 0xf7, 0x10, 0x46,
	0x97, 0x36, 0x0d, 0xf9, 0xd0, 0x2b, 0x65, 0x82, 0x3b, 0xd3, 0xce, 0xdc, 0x25, 0xda, 0x44, 0x9f,
	0xc2, 0x40, 0x09, 0x95, 0x70, 0xdc, 0x35, 0x98, 0x75, 0xd0, 0x14, 0x3c, 0xc6, 0x8b, 0xbd, 0x14,
	0xb9, 0x12, 0x59, 0x8a, 0x7b, 0x26, 0x76, 0x0a, 0x21, 0x0c, 0xa3, 0x3f, 0x79, 0x9c, 0xd3, 0x3b,
	0x8e, 0xfb, 0x26, 0x5a, 0xbb, 0xe8, 0x73, 0x00, 0x91, 0x32, 0xfe, 0x9e, 0xb3, 0x88, 0x2a, 0x3c,
	0x30, 0x41, 0xb7, 0x42, 0x16, 0x0a, 0x7d, 0x07, 0x4e, 0x92, 0xed, 0xa9, 0xe9, 0x3b, 0x9c, 0x76,
	0xe6, 0xde, 0xab, 0xf3, 0x8b, 0xff, 0xdf, 0xfa, 0x62, 0x5d, 0xe5, 0x90, 0x26, 0x1b, 0x7d, 0x09,
	0xe3, 0x5c, 0x66, 0x0f, 0x82, 0x71, 0x19, 0x95, 0x82, 0xe1, 0x91, 0xbd, 0x55, 0x8d, 0xed, 0x04,
	0xd3, 0xcd, 0x0f, 0x5c, 0x51, 0x46, 0x15, 0xc5, 0xce, 0xb4, 0xf7, 0x54, 0xf3, 0xeb, 0x2a, 0x87,
	0x34, 0xd9, 0xe8, 0x47, 0x80, 0x07, 0x51, 0x88, 0x58, 0x24, 0x42, 0x1d, 0xb1, 0x3b, 0xed, 0xcc,
	0x27, 0xaf, 0xbe, 0x78, 0xac, 0xf6, 0x97, 0x26, 0x8b, 0x9c, 0x54, 0xa0, 0x25, 0x8c, 0x75, 0x9f,
	0x28, 0x11, 0x7b, 0x9e, 0x16, 0x1c, 0x83, 0x19, 0xed, 0xc5, 0x63, 0x1d, 0xae, 0xa8, 0xa2, 0x6b,
	0x9b, 0x46, 0x3c, 0xd6, 0x3a, 0xe8, 0x12, 0xc6, 0x54, 0x29, 0x29, 0xe2, 0x52, 0xcf, 0x5b, 0x60,
	0xcf, 0x4c, 0xf0, 0x68, 0x8f, 0x45, 0x9b, 0x47, 0x3e, 0x28, 0x42, 0xdf, 0xc0, 0xf3, 0x32, 0x67,
	0x54, 0xf1, 0x48, 0xa4, 0x8a, 0xcb, 0x07, 0x9a, 0xe0, 0xf1, 0xb4, 0x33, 0x1f, 0x90, 0x89, 0x85,
	0x57, 0x15, 0x8a, 0xbe, 0x82, 0xb3, 0x77, 0x25, 0x4d, 0x95, 0x50, 0xc7, 0xe8, 0x0f, 0x91, 0x32,
	0x7c, 0x66, 0xf8, 0x1c, 0xd7, 0xe0, 0x5b, 0x91, 0x32, 0x84, 0xa0, 0x5f, 0xa6, 0x42, 0xe1, 0x89,
	0x89, 0x19, 0x1b, 0x7d, 0x0b, 0x88, 0x65, 0x07, 0x2a, 0xd2, 0x28, 0xbb, 0xb5, 0x87, 0xf0, 0x42,
	0xe1, 0xe7, 0xd3, 0xde, 0xdc, 0x25, 0xbe, 0x8d, 0x6c, 0x6e, 0x57, 0x15, 0x8e, 0x5e, 0x80, 0x77,
	0xe0, 0xb4, 0x28, 0x25, 0x67, 0x51, 0x7c, 0xc4, 0xbe, 0x69, 0x04, 0x35, 0xb4, 0x3c, 0xa2, 0xef,
	0xc1, 0x35, 0xcc, 0xa9, 0x63, 0xce, 0xf1, 0x27, 0x86, 0xf8, 0xf3, 0xa7, 0x68, 0xdb, 0x1e, 0x73,
	0x4e, 0x1c, 0x56, 0x59, 0x9a, 0xb0, 0x2c, 0x2e, 0xf4, 0x38, 0x96, 0x30, 0xf4, 0x34, 0x61, 0x9b,
	0x36, 0x8f, 0x7c, 0x50, 0x34, 0x7b, 0x0d, 0xde, 0x09, 0x9b, 0x7a, 0xe2, 0x90, 0x1e, 0x78, 0xa5,
	0x11, 0x63, 0x6b, 0xd9, 0xec, 0xc8, 0xba, 0x92, 0x88, 0x36, 0x67, 0x31, 0x38, 0xf5, 0x86, 0xa2,
	0x73, 0x70, 0x93, 0x2c, 0xbd, 0x13, 0xaa, 0x64, 0xb6, 0xac, 0x4b, 0x5a, 0x00, 0x7d, 0x06, 0x4e,
	0x42, 0x95, 0x0d, 0x76, 0x4d, 0xb0, 0xf1, 0x75, 0x25, 0x4f, 0xb8, 0xbd, 0x88, 0x11, 0x59, 0x97,
	0xb4, 0xc0, 0xec, 0x07, 0x70, 0xea, 0x45, 0xd5, 0x5d, 0x72, 0x99, 0xe5, 0x5c, 0xaa, 0x63, 0x75,
	0xb3, 0xc6, 0xd7, 0x12, 0x7e, 0xa0, 0x49, 0xd9, 0x48, 0xd8, 0x38, 0xb3, 0xbf, 0xc0, 0x3b, 0x99,
	0x59, 0x3f, 0x83, 0xe4, 0xfb, 0x4c, 0x32, 0x2b, 0x4b, 0xdb, 0x03, 0x6a, 0xe8, 0x3f, 0xba, 0xec,
	0x7e, 0x94, 0x2e, 0x9b, 0xf3, 0x7b, 0xa7, 0xe7, 0xff, 0xd3, 0x01, 0xef, 0x64, 0xd3, 0x35, 0xaf,
	0xe9, 0x09, 0xaf, 0x69, 0xc5, 0xab, 0xfe, 0x8e, 0xba, 0xed, 0x77, 0xf4, 0x35, 0x4c, 0x12, 0x7e,
	0x47, 0x93, 0x68, 0x9f, 0x31, 0x1e, 0xe9, 0xa0, 0x6d, 0x3a, 0x36, 0xe8, 0x65, 0xc6, 0xf8, 0x4e,
	0x26, 0xfa, 0xf3, 0xc9, 0xb9, 0x3c, 0x08, 0x55, 0xe0, 0xbe, 0x59, 0xbb, 0xda, 0xd5, 0x3c, 0x49,
	0xfe, 0xae, 0x14, 0x92, 0x17, 0x78, 0x60, 0x42, 0x8d, 0xaf, 0xd9, 0xce, 0x65, 0x76, 0x2f, 0x62,
	0x5d, 0x37, 0x34, 0xc1, 0x16, 0x78, 0x79, 0x01, 0xd0, 0x4a, 0x1b, 0x39, 0xd0, 0xdf, 0xfc, 0x1c,
	0x84, 0xfe, 0x33, 0x04, 0x30, 0xbc, 0xf9, 0x69, 0x41, 0x82, 0x2b, 0xbf, 0xa3, 0xed, 0xcb, 0xf5,
	0xe6, 0x26, 0xb8, 0xf2, 0x7b, 0x2f, 0x0f, 0xe0, 0xd4, 0x1b, 0xa9, 0xf1, 0x70, 0x77, 0xbd, 0x0c,
	0x88, 0xff, 0x0c, 0x79, 0x30, 0x5a, 0x85, 0xdb, 0xe0, 0x4d, 0x40, 0x6c, 0xc1, 0xcd, 0x96, 0xac,
	0xc2, 0x37, 0x7e, 0x17, 0x9d, 0x81, 0x7b, 0xb5, 0xd8, 0x06, 0xd1, 0x76, 0x75, 0x1d, 0xf8, 0x3d,
	0x7d, 0x82, 0xb1, 0xfa, 0xba, 0x62, 0xb9, 0xd9, 0xac, 0x83, 0x45, 0xe8, 0x0f, 0x90, 0x0b, 0x83,
	0xe5, 0x6f, 0xdb, 0xe0, 0xc6, 0x1f, 0x6a, 0x7c, 0x17, 0xbe, 0x0d, 0x37, 0xbf, 0x86, 0xfe, 0x68,
	0xe9, 0xfd, 0xee, 0x36, 0xaf, 0x11, 0x0f, 0xcd, 0x73, 0xbc, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff,
	0xf9, 0xf0, 0x31, 0x21, 0xff, 0x05, 0x00, 0x00,
}
